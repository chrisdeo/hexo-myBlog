---
title: 模块的发展演变及包的构建与发布
date: 2019-08-16 08:30:03
tags:
  - 工程化
  - npm
  - CMD
  - AMD
  - CommonJS
  - webpack
---

> &emsp;求同存异，站在巨人的肩膀上。

&emsp;&emsp;上周我做了一篇从`roadhog`到`webpack`项目编译打包迁移的share。算是理清了`webpack`的脉络。但是同时也引出了我早期学习前端的另一个问题：**工程中的模块化在我们前端项目里具体是如何体现的。**

<escape><!-- more --></escape>

## 模块化的具体体现是什么？

&emsp;&emsp;这个问题很容易造成初识这块内容的朋友的混淆，当然这可能也跟没有摸过NodeJS、没有自己构建过项目有关。

&emsp;&emsp;开始说体现前，先理清几个内容：
&emsp;&emsp;1. 虽然在我们的开发项目中有各种组件、引入库、样式、模板，但最后部署到我们的服务器上（本地开发的`webpack-dev-server`、云服务器、机房的服务器等等）就只剩几个类型的文件了：`html`，也就是我们访问的web；整个工程编译打包后的`js`文件，它会在`script`中引入；所有CSS处理压缩后的一个通过`link`引入的样式文件，部分放在服务器静态资源目录的文件。**从某种角度上而言，说最后输出的就是一个HTML文件也无妨，只不过在HTML内部引入了所需的`js`、`css`，资源文件（图片、音频等）**。这也是工程化给前端开发者开发带来了跨越式提升的原因。
&emsp;&emsp;2. 有了上面的描述，相信各位已经可以很明显的看出来其实我们经过编译工具打包出来的文件其实是不存在什么“模块化”的，换言之，**在浏览器端是不存在模块化的。**也许你会问，那之前那些模块是怎么处理到浏览器的全局作用域内的，别急，后文会把你安排清楚。

&emsp;&emsp;ok，现在大家都知道模块化不是浏览器那块的事了，那结果也很好确认了。没错，模块化其实就是从NodeJS开始的。2009年的时候，Ryan Dahl整出了NodeJS，并用于JavaScript的服务端编程，同时标志着JS模块化编程的诞生。Node中的模块规范是参照`CommonJS`实现的，使用方式大致如下：

```javascript
  const sum = require('sum');
  sum(1,2,3,4,5); // 15
```

&emsp;&emsp;